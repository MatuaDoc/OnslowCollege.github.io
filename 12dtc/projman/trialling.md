---
title: Testing & trialling
grand_parent: 12DTC
parent: Advanced Processes
nav_order: "be"
---

As part of your project, you are required to test and trial the components that you develop. These are the basic requirements for **Achieved**, so you should not skip out on this important part of the process.

We all want to produce the best outcome that we can. Unfortunately, it’s easy to produce a less-than-perfect product if robust testing and trialling processes aren’t in place.  

It's often hard to see our own mistakes - we are very close to our outcome, making us unable to see flaws as easily as an outsider might. Have you ever asked a friend to proofread your essay? They often pick up errors that you hadn’t even considered. 

## When should testing and trialling happen? 
 
Test and trial as you make each component!

As you work you need to test your work regularly - for code this might mean running it to check changes every few minutes, for a print outcome this might mean doing a print preview. Taking occasional screenshots is an easy way to add this to your evidence for this standard.  

You should explore and try things out as you go. Occasionally you will try things that don’t end up working, so you don’t end up using them. Other times you may have made a component and then found a better idea to use. Sometimes you will have choices and will seek feedback from someone else.

All these things are [trialling](#trialling). You could make brief notes about what components or techniques you tried, which ones you ended up using, and why. Keeping a log book or adding to your evidence document as you work is a good way to do this, because chances are you will forget all the little decisions you made if you wait until the end of the project.
 
As you complete each component you might need to do slightly more formal testing - validate your code, test the component with a range of inputs, gain user feedback regarding whether the component is fit for its intended purpose.  
 
Checklist - testing and trialling to do THROUGHOUT the development process: 

- run or preview outcome regularly 
- validate code (if relevant) 
- trial different options 
- get feedback  
- make decisions 
- before and after screen-shots (if applicable)
- keep a log book, make notes 
- continual improvements if possible 
 
## Final testing of completed outcome

Final testing is generally more formal, and is of the outcome as a whole rather than smaller parts. You would either create a **full** testing table and verify that your code or game works with a range of expected, boundary and unexpected inputs, or you might screen-record a video showing you testing your outcome.

You should also verify that your outcome meets its requirements, and (if possible) that potential users are happy with it.

It’s good to allow time after the final testing in case you need to make improvements! 
 
Checklist - testing and trialling to do AT THE END of the project: 

- run a thorough test of all functionality  
- keep a record of final testing 
- do final user testing 
- improve or fix if needed 

# Testing

Testing is straight-forward. You are checking whether your component functions as intended.

For programming testing, the portfolio provides a small version of the testing table from the Programming Assessment. Use this to test the components that you have worked on in a given sprint.

----

Since you also know exactly how your outcome is supposed to work, and may be tempted only to test it in the expected situations rather than comprehensively testing it by 'trying to break it' - trying it under many different conditions or using varied boundary and unexpected inputs. A robust program or a high-quality outcome should work well no matter what we throw at it. 

Though you are not required to find EBI (expected/boundary/invalid) cases as part of the standard itself, you should continue to do this — exercise best practice to ensure that your components can actually move from the testing phase to completion.

> If you do not thoroughly and accurately test your components, they will not be able to move to completion. This will clog up your Testing and In-Progress sections in your project boards. **Test properly and thoroughly!**

----

When you complete each component you need to test it to make sure it meets the requirements. This might involve running your program with a wide variety of inputs, or testing your outcome on various devices and screen sizes, to ensure it works as intended. Popular ways to keep a record of this are in a screen recording video or in a testing table.  
	  
Having other people test your code is a good idea, as they will use it differently and may spot problems that you missed. Ask them to try to break it - only when they can't fault it any more will you know you have a sound solution. 

# Trialling

Trialling is a process of trying different things to see what works best for the component.

Similar to the design process you explored in 11DIT, you can think of this as a feedback cycle:

- you have tried a couple of different approaches to the component
- you ask your end-users/classmates/teacher which approach they think works best
- based on their feedback, you make a decision about which approach to use

Not all trialling needs to be feedback-based. You may trial different ways to structure the code of a component — for example, lists vs 2D lists vs dictionaries — and wish to determine which would be best. In that case, you could do a PMI analysis of each approach, then select the one you wish to continue with in your development.

## Example 1

***What components are you going to trial?***

One of the things that will need to be done during Sprint 1 is a good description of the game, one per user group. The description needs to clearly explain the goal of the game and how to play – for the students, and functionality of the game and how to use it – for the teachers. 

| | |
| :-- | :-- |
| **Option 1** | Dear colleagues, thank you for choosing Simple math quiz for your classroom. The aim of the program is to help you to ascertain student’s previous maths knowledge in a fun and engaging way. Research determined that uncertainty of an upcoming reward has been a great motivator for the students to keep playing the game and learning essential math skills in the process. As a teacher you have an option to change the questions to make them easier or harder, depending on the year level. The student’s will be able to rate the questions difficulty, giving you an indication of their confidence levels. The report printed at the end will have all the questions answered with rating the student gave them. Hope you and your students enjoy the game. For support email contact@simplemaths.co.nz or call 0800 FUNMATH. |
| **Option 2** | Kia Ora koutou katoa. Great times ahead of us! Welcome to Simple maths! Great to see you here. Simple game the students will love due to the uncertainty of the final reward. Functional game for you. Adjust the question to your needs. Print the final report and let it guide your pedagogy. Win win all around. If any questions occur do not hesitate to reach us on contact@simplemaths.co.nz or call us on 0800 FUNMATH. |
| **Option 3** | Welcome everyone! Such a great day to teach and learn about maths. At simple maths we value your time and want to make math fun for our learners. With two menus (one for teachers and one for students) we achieve just that. Your students will be able to play, learn and have fun, while you are in full control of what questions they get. The program also prints out a handy report to help you plan. The uncertain reward is what will bring the students back time after time. Check it out. Any feedback is appreciated. You can reach us on contact@simplemaths.co.nz or call directly 0800 FUNMATH. |

**Feedback**

| | |
| :-- | :-- |
| **Component** | Teacher's game description |
| **Name** | Mr Example |
| **Feedback** | Like the first option, but include Te Reo in it. |

| | |
| :-- | :-- |
| **Component** | Teacher's game description |
| **Name** | Mx Sample |
| **Feedback** | I like how descriptive option 1 is. I think it gives a really good overview. I like the use of Te Reo Maori in option two but think the rest is a little too informal. I don’t like option three – it feels more like a sales pitch than a description. I think option one works best but would like to include some Te Reo in it too. |

| | |
| :-- | :-- |
| **Component** | Teacher's game description |
| **Name** | Ms Exemplar |
| **Feedback** | The first option is a very comprehensive overview of all the functions the program has for teachers to help their students. However, the language in the first option is very formal and could perhaps be more casual and friendly. I also like the use of Te Reo in the second option as it is an important part of our cultural identity. Perhaps this could be used in place of the greeting of the first option. |

***What is the outcome of my feedback?***

From all of the feedback the teachers gave it is obvious that Te Reo will need to be included in the description to show the commitment to the Treaty of Waitangi and the role that education plays in promotion of that commitment. Otherwise the first option will be reviewed and updated to be less formal, but just as descriptive.

**Final version**

Kia Ora koutou katoa and thank you for choosing Simple math quiz for your classroom. The aim of the program is to help you to ascertain student’s previous maths knowledge in a fun and engaging way. Research determined that uncertainty of an upcoming reward has been a great motivator for the students to keep playing the game and learning essential math skills in the process. As a teacher you have an option to change the questions to make them easier or harder, depending on the year level. The student’s will be able to rate the questions difficulty, giving you an indication of their confidence levels. The report printed at the end will have all the questions answered with rating the student gave them. Hope you and your students enjoy the game. For support email contact@simplemaths.co.nz or call 0800 FUNMATH. 

## Example 2

***What components are you going to trial?***

I need to store the different attacks that the hero will be able to do in a data structure, but I'm not sure which. I will try using the three collection types that we have learnt in 11DIT and 12DTC. I have created code samples of how each of these would look.

| Option 1 | Option 2 | Option 3 |
| :-- | :-- | :-- |
| Lists | 2D Lists | Dictionary |

**Feedback**

```python
attacks = ["Punch", "Sword", "Hammer"]
power = [5, 25, 50]
```

| | |
| :-- | :-- |
| **Component** | List |
| **Name** | Me |
| **Feedback** | P: these are easy to understand |
| | N: I have to store the damage in a separate list |

```python
attacks = [["Punch", 5], ["Sword", 25], ["Hammer", 50]]
```

| | |
| :-- | :-- |
| **Component** | 2D Lists |
| **Name** | Me |
| **Feedback** | P: I can store the different types of attacks in different lists within the main attack list |
| | N: I have to remember all the different indices for each different type of attack |

```python
attacks = {
    "Punch": 5,
    "Sword": 25,
    "Hammer": 50
}
```

| | |
| :-- | :-- |
| **Component** | Dictionary |
| **Name** | Me |
| **Feedback** | P: these are easy to understand, and I can store different attack types under different keys. These are more descriptive than 2D list indices |
| | N: I'm not as experienced with dictionaries |

***What is the outcome of my feedback?***

I have trialled using all the types and analysed them. From this, I have concluded that lists are unsuitable because I can't separate out different types of attacks. Of the two remaining types, dictionaries are easier to model because I don't have to remember which position in the main list I need to get the attack data from.

I will use dictionaries for the attack list.